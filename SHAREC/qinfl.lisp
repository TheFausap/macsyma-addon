;;; Quantum information package	                  -*-LISP-*-

;; flip a qubit
(DEFUN $FLIP (X) (REMAINDER (+ X 1) 2))

(DEFUN $SCHMIDT_KET (A) (ADD* (MUL* (POWER A (DIV* 1 2)) 
				    (MFUNCALL '$KETZ 0 0))
			      (MUL* (POWER (SUB* 1 A) (DIV* 1 2))
				    (MFUNCALL '$KETZ 1 1))))
;;PURITY
(DEFUN $PURITY (RHO) (MFUNCALL '$MAT_TRACE  (NCMUL2 RHO RHO)))

;; IDENTITYMATRIXP
(DEFUN $IDENTITYMATRIXP (A) (MFUNCALL '$ZEROMATRIXP (ADD* A (*MMINUS
						      ($IDENT ($LENGTH A))))))

;; RETURN INTEGER VALUE FROM VECTOR (OR LIST) OF NUMERATION.
;; VEC -- VECTOR OF NUMERALS.
;; B   -- THE BASE.
;; BITS ARE ARRANGED HERE FROM LEAST TO MOST SIGNIFICANT
;; LEFT TO RIGHT.
;; THE SAME AS FROMDIGITS, BUT THE ORDER OF DIGITS IS REVERSED. THIS SITUATION
;; SHOULD BE RATIONALIZED AND A GENERICALLY NAMED FUNCTION SHOULD BE USED
(DEFUN $PTRACE_VEC_TO_INT (VEC B)
  (LOOP FOR I FROM 0 BELOW (1- (LENGTH VEC))
	SUM (* (MARRAYREF VEC (1+ I)) (POWER B I)) INTO RES
	FINALLY (RETURN RES)))

(DEFUN $PTRACE_INC_VEC (VEC B)
  (LOOP FOR I FROM 1 TO (+ (LENGTH VEC) -1) DO
	(MARRAYSET (+ 1 (MARRAYREF VEC I)) VEC I)
	(IF (= (MARRAYREF VEC I) B)
	    (LOOP FOR J FROM 1 TO I DO
		  (MARRAYSET 0 VEC J))
	    (RETURN T))))

(DEFUN $COMMUTATOR (A B)
  (ADD* (NCMUL2 A B) (*MMINUS (NCMUL2 B A))))

(DEFUN $ANTICOMMUTATOR (A B)
  (ADD* (NCMUL2 A B) (NCMUL2 B A)))

(DEFUN TRANSPOSE (X)
  (APPLY #'MAPCAR (CONS #'LIST X)))

;; THESE TWO TRANSFORMATIONS USE UNDOCUMENTED LISP FNCS FROM THE SOURCE
;; THEY TRANSFORM BETWEEN LISP STYLE MATRIX AND MACSYMA MATRIX

(DEFUN MXC1 (X)
  (CONS '($MATRIX) (MXC X)))

;; MACSYMA TO MATRIX
(DEFUN MCX1 (X)
  (MCX (CDR X)))

(DEFUN LST-TO-MX (X)
  (CONS '(MLIST SIMP) X))

(DEFUN MX-TO-LST (X)
  (CDR X))

(DEFUN $MIDENT (X)
  (LST-TO-MX (MX-TO-LST X)))

(DEFUN $MYMATTRANS (M)
  (MXC1 (TRANSPOSE (MCX1 M))))
